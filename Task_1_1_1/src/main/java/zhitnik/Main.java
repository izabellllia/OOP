package zhitnik;

public class Main { //объявляем класс Main
    public static void heapSort(int[] array) { //объявляем метод hS
        //Модификатор доступа public указывает, что метод или переменная может быть доступна из любого места в программе, включая другие классы и пакеты. В случае объявления метода с модификатором доступа public, он может быть вызван из любого места программы, не только из класса, в котором он объявлен
        //Статический модификатор static указывает, что метод или переменная принадлежит классу, а не конкретному объекту этого класса. Это означает, что статические методы и переменные могут быть использованы без необходимости создания экземпляра класса
        int n = array.length; //иниц n с длиной массива

        //Начинаем построение max-кучи. Идем по элементам с конца до середины
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(array, n, i);//Внутри цикла вызываем метод heapify для каждого элемента массива. Метод heapify принимает массив, его размер и индекс текущего элемента

        // Начинаем извлекать элементы из кучи по одному и перестраивать кучу. Итерируемся по элементам массива с конца до начала (индекс i уменьшается на 1 на каждой итерации)
        for (int i = n - 1; i >= 0; i--) {
            // Внутри цикла перемещаем текущий корень (наибольший элемент) в конец массива, меняя местами значения текущего элемента и элемента с индексом i.
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;

            //ызываем метод heapify на уменьшенной куче (размер уменьшается на каждой итерации цикла), чтобы восстановить свойство max-кучи
            heapify(array, i, 0);
        }
    }

    public static void heapify(int[] array, int n, int i) {
        int largest = i; // индекс текущего элемента, который считаем наибольшим
        //Вычисляем индексы левого и правого дочерних элементов относительно текущего элемента
        int leftChildIdx = 2 * i + 1;
        int rightChildIdx = 2 * i + 2;

        // Проверяем, если левый дочерний элемент меньше размера массива и значение левого
        // дочернего элемента больше значения наибольшего элемента (array[leftChildIdx] > array[largest]),
        // то обновляем значение переменной largest на индекс левого дочернего элемента
        if (leftChildIdx < n && array[leftChildIdx] > array[largest])
            largest = leftChildIdx;

        // Проверяем, если правый дочерний элемент меньше размера массива и значение правого дочернего элемента больше
        // значения наибольшего элемента, то обновляем значение переменной largest на индекс правого дочернего элемента
        if (rightChildIdx < n && array[rightChildIdx] > array[largest])
            largest = rightChildIdx;

        // Проверяем, если наибольший элемент не является корнем (текущим индексом i),
        // то меняем местами значения текущего элемента и наибольшего элемента в массиве
        if (largest != i) {
            int swap = array[i];
            array[i] = array[largest];
            array[largest] = swap;

            //Рекурсивно вызываем метод heapify для поддерева с новым наибольшим элементом
            heapify(array, n, largest);
        }
    }
}